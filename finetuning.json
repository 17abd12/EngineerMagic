{
  "Test_1": {"prompt": "Please make me a basic flat gear with a hole in the middle and sawtooth shaped teeth in OpenSCAD.", "completion": "difference() {\n  cylinder(h=2,r=17);\n  cylinder(h=2,r=3,$fn=25);\n  }\n  \n  for(i=[1:1:20]){\n  rotate([0,0,(360/20)*i])\n  translate([18,0]) linear_extrude(2) \n  circle(3,$fn=3);\n  }\n  "},
  "Test_2": {"prompt": "Please make me a ball bearing in OpenSCAD with reasonable dimensions", "completion": "rotate_extrude($fn=50){\n  difference() {\n  translate([10, 0, 0]){\n  square([10, 9], center=true);\n  }\n  \n  translate([15, 0, 0]){\n  circle(r=5);\n  }\n  }\n  difference() {\n  translate([20, 0, 0]){\n  square([10, 9], center=true);\n  }\n  \n  translate([15, 0, 0]){\n  circle(r=5);\n  }\n  }\n  }\n  for (i = [1 : abs(1) : 10]) {\n  rotate([0, 0, (i * 36)]){\n  translate([15, 0, 0]){\n  {\n  $fn=50;  //set sides to 50\n  sphere(r=4.5);\n  }\n  }\n  }\n  }\n  "},
  "Test_3": {"prompt": "Please make me a raspberry pi 3 case in OpenSCAD. You can look up the dimensions to see what's necessary", "completion": "part = \\\"all\\\"; // [ top, bottom, all, demo ]\\n\\n  have_plugrow = 0; // [ 1:true, 0:false ]\\n  have_open_plugrow = 0; // [ 1:true, 0:false ]\\n  have_camera = 0; // [ 1:true, 0:false ]\\n  have_sdcard_support = 1; // [ 1:true, 0:false ]\\n  have_leds = 1; // [ 1:true, 0:false ]\\n  \\n  /* [Hidden] */\\n  mil2mm = 0.0254;\\n  \\n  pcb = [85.0, 56.0, 1.5]; // main board\\n  pcb2floor = 4.0; // 3.5\\n  pcb2roof = 17.0; // 15.7\\n  \\n  pcbmntdia = 2.75; // mounting holes"},
  "Test_4": {"prompt": "Please make me a nut in OpenSCAD", "completion": "//nut_M(3,1,0.1);\n  //nut_M(6,1,0.1);\n  nut_M_border(6,10,3,0.1);\n  \n  module nut_M(size,height,clear)\n  {\n  nut_hexagonal(size,height,clear);\n  }\n  \n  module nut_M_border(size,radius,height,clear)\n  {\n  difference() {\n  //cylinder(r=radius, h=height,center=true);\n  nut_hexagonal(radius,height,clear);\n  nut_hexagonal(size,height,clear);\n  }\n  }\n  \n  module nut_hexagonal(radius,height,clear)\n  {\n  height = height+clear;\n  radius = radius+clear;\n  angle = 360/6;\n  cote = (radius)/tan(angle);\n  \n  union()\n  {\n  rotate([0,0,0])\n  cube([radius,cote,height],center=true);\n  rotate([0,0,angle])\n  cube([radius,cote,height],center=true);\n  rotate([0,0,2*angle])\n  cube([radius,cote,height],center=true);\n  }\n  }\n  "},
  "Test_5": {"prompt": "Please make me a water bottle cap in OpenSCAD. Use standard measurements for a 16 oz bottle", "completion": "// $Header$\n\n  // cap/mount for PET bottle, usually 16oz, 20oz, 1l, 2l\n  \n  // Adapted from https://www.thingiverse.com/thing:897760\n  \n  sides = 50;\n  \n  threadOD = 27.4;\n  threadID = 24.7;\n  neckD = 21.4;\n  \n  // thread base width 2.2\n  threadPitch = 2.9;//3.2;\n  nTurns = 2.3;\n  toLip = 11;\n  \n  threadDepth = (threadOD-threadID)/2;\n  \n  bottle_top();\n  bottle_cap();\n  \n  module bottle_top() {\n  \n  union() {\n  translate([0,0,-2.9])\n  cylinder(r=threadID/2+3,h=3,$fn=sides);\n  cylinder(r=threadID/2-.2,h=toLip,$fn=sides);\n  // can't really do a hull to make threads thicker, so\n  // just repeat them.  Its not perfect, but you won't be able\n  // to tell by the time it gets through the slicer\n  for(offst=[.4,.7,1]) translate([0,0,3.25-offst])\n  linear_extrude(height=nTurns*threadPitch,twist=-nTurns*360)\n  translate([threadDepth,0,0]) circle(r=threadID/2 + threadDepth/2);\n  }\n  }\n  \n  // for removing from a solid to make a place\n  // where a PET bottle can be screwed in\n  module bottle_tap(h=10) {\n  hh=h+0.5; // a little thread over the top\n  union() {\n  translate([0,0,-1]) cylinder(r=threadOD/2+.3,h=1  ,$fn=sides);\n  translate([0,0,-2]) cylinder(r=threadID/2+.3,h=h+2,$fn=sides);\n  \n  // can't really do a hull to make threads thicker, so\n  // just repeat them.  Its not perfect, but you won't be able\n  // to tell by the time it gets through the slicer\n  for(offst=[-.05,-.25,-.45,-.65]) translate([0,0,offst])\n  linear_extrude(height=hh,twist=-(hh/threadPitch)*360,slices=80)\n  translate([threadDepth,0,0])\n  circle(r=threadID/2 + threadDepth/2,$fn=48);\n  }\n  }\n  \n  module bottle_cap() {\n  translate([0,0,9]) {\n  difference () {\n  cylinder(r=threadOD/2+3,h=18,center=true,$fn=sides);\n  translate([0,0, 1]) bottle_tap();\n  translate([0,0,-9.1]) cylinder(r2=threadID/2,r1=threadOD/2+.3,h=2,$fn=sides);\n  }\n  }\n  }\n  "},
  "Test_6": {"prompt": "Can you make me code in OpenSCAD that can make pipes. It can also be use to make washers if the height is small enough", "completion": "module pipe(pipe_diameter,pipe_hull,height){\n  difference() {\n cylinder(r=pipe_diameter/2+pipe_hull, h=height, $fn=sides);\n translate([0,0,-0.05])\n \n cylinder(r=pipe_diameter/2, h=height+0.1, $fn=sides);\n  }\n \n }\n \n pipe(10, 5, 10);\n "},
  "Test_7": {"prompt": "Can you make me a hose barb adapter?", "completion": "/*\n  Adapted from: Hose barb adapter and manifold by papergeek  www.thingiverse.com/thing:158717\n  \n  */\n  \n  sides = 200;\n  \n  tube_connector(4, 1, 4, 0, 4);\n  \n  module tube_connector_unit(Size=4, Size_barb_count=4, Size_Bore) {\n  difference() {\n  union() {\n  for ( i = [1:Size_barb_count]) {\n  translate([0, 0, (i - 1) * Size * 0.9])\n  cylinder( h = Size , r2 = Size * 0.85 / 2, r1 = Size * 1.16 / 2, $fa = 0.5, $fs = 0.5, $fn=sides);\n  }\n  }\n  translate([0, 0, -0.1])\n  cylinder(h=Size*Size_barb_count , d=Size_Bore, $fa=0.5, $fs=0.5, $fn=sides);\n  }\n  }\n  \n  \n  module tube_connector(Size=4, Wall_Thickness=1, Size_barb_count = 4, Shoulder=1, Shoulder_height) {\n  \n  Size_Bore = Size - (Wall_Thickness * 2);\n  Size_1 = Size + 2*Shoulder; // size of manifolds \n  \n  union() {\n  translate([0, 0, Shoulder_height/2])\n  difference() {\n  cylinder( h = Shoulder_height , d = Size_1, center = true, $fa = 0.5, $fs = 0.5, $fn = 100 )  ;\n  cylinder(h = Shoulder_height + 1, d1 = Size_Bore, d2 = Size_Bore, center = true, $fa = 0.5, $fs = 0.5 );\n  }\n  translate([0, 0, Shoulder_height]) {\n  tube_connector_unit(Size, Size_barb_count, Size_Bore);\n  }\n  }\n  }\n "},
  "Test_8": {"prompt": "Can you make me the code for a flower pot in OpenSCAD. It also can double as a trash can, I kind of want a cylinder with an open top and a slight taper toward the bottom", "completion": "sides = 200;\n\n  flower_pot(120, 65, 40, 2);\n  \n  module flower_pot(height, top_radius, bottom_radius, wall) {\n  difference() {\n  cylinder(r1=bottom_radius,r2=top_radius,h=height, $fn=sides);\n  translate([0,0,wall])\n  cylinder(r1=bottom_radius-wall,r2=top_radius-wall,h=height, $fn=sides);\n  }\n  }\n "},
  "Test_9": {"prompt": "Can you make me a dog's water bowl in OpenSCAD", "completion": "sides = 200;\n\n  circular_plug(110,130,20,5,5);\n  \n  module circular_plug(bottom_diameter,top_diameter,height,wall_thickness,bottom_thickness) {\n  difference() {\n  union() {\n  cylinder(h=bottom_thickness, r1=bottom_diameter/2, r2=bottom_diameter/2, $fn=sides);\n  cylinder(h=height, r1=bottom_diameter/2, r2=top_diameter/2, $fn=sides);\n  }\n  translate([0,0,bottom_thickness])\n  cylinder(h=height-bottom_thickness+0.01, r1=bottom_diameter/2-wall_thickness, r2=top_diameter/2-wall_thickness, $fn=sides);\n  }\n  }\n  "},
  "Test_10": {"prompt": "Can you write the openscad code for an OLED display with some screw holes, kind of like the small displays electrical engineers use", "completion": "module oled_display(width=28, height=22, thickness=2) {\n\n  difference() {\n  color(\"green\") cube([width,height,2], center=true);\n  // holes\n  translate([width/2-2,height/2-2,-2.5]) cylinder(r=1, h=4);\n  translate([-width/2+2,height/2-2,-2.5]) cylinder(r=1, h=4);\n  translate([-width/2+2,-height/2+2,-2.5]) cylinder(r=1, h=4);\n  translate([width/2-2,-height/2+2,-2.5]) cylinder(r=1, h=4);\n  }\n  color(\"blue\") translate([0,0,2]) cube([width-thickness*3,height-thickness*3,thickness], center=true);\n  \n  }\n  oled_display();\n  "},
  "Test_11": {"prompt": "Can you make me a ball and socket joint in OpenSCAD please?", "completion": "// Ball joint in SCAD by Erik de Bruijn\n  // Based on a design by Makerblock ( http://makerblock.com/2010/03/blender-help/ )\n  size=10; // size of the ball joint\n  joint_spacing =0.5; // some space between them?\n  joint_thickness = 2; // thickness of the arms\n  joint_arms = 5; // how many arms do you want?\n  arm_width = 10; // actually: how much is removed from the arms Larger values will remove more\n  \n  //render settings\n  $fs=0.8; // def 1, 0.2 is high res\n  $fa=4;//def 12, 3 is very nice\n  \n  //print();\n  \n  ball();\n  //\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  joint();\n  \n  \n  //translate([size*2+10,0,0]) ball();\n  //rotate([0,180,0]) joint();\n  \n  \n  module ball()\n  {\n  sphere(r=size);\n  translate([0,0,-size]) cylinder(r1=8,r2=6,h=3);\n  translate([0,0,-size-3]) cylinder(r=8,h=3);\n  }\n  \n  \n  \n  module joint()\n  {\n  difference()\n  {\n  sphere(r=size+joint_spacing+joint_thickness);\n  sphere(r=size+joint_spacing);\n  translate([0,0,-size-3]) cube([size+joint_spacing+joint_thickness+25,size+joint_spacing+joint_thickness+25,18],center=true);\n  for(i=[0:joint_arms])\n  {\n  rotate([0,0,360/joint_arms*i]) translate([-arm_width/2,0, -size/2-4])\n  cube([arm_width,size+joint_spacing+joint_thickness+20,size+6]);\n  }\n  }\n  translate([0,0,size-2]) cylinder(r2=8,r1=8,h=5);\n } "},
  "Test_12": {"prompt": "Can you make me a Hith joint in OpenSCAD please", "completion": "// author:  Lukas SÃ¼ss aka mechadense\n  // date:  2014-07\n  // title: Hirth-Joint (CSG version)\n  // license: public domain\n  \n  /*\n  Customizable Hith Joint (CSG version) (library)\n  \n  This is an improved version of\n  http://www.thingiverse.com/thing:387292\n  \n  This improved model can start the teeth not just at the center but also at a polygon of choosable radius. Meaning one can create thin walled tube couplings that are radially self centering (Such couplings are often found in Mountainbike axles).\n  \n  The interpenetration depth of the teeth can be limited with the flatlimit parameter.\n  \n  \n  ## Specialised functions\n  hirthaxle(l,d,dbore,n,beta,delta,flatlimit)\n  hirthtube(l,d,dbore,n,beta,delta,flatlimit)\n  \"axle\"-postfix: all teeth converge to the center\n  \"tube\"-postfix: all teeth emerge from the polygon inscribed into the bore diameter\n  \n  ## Convinience functions that make the coupling printeable upside down:\n  supportlesshirthaxle(l,d,dbore,n,beta,delta,flatlimit)\n  supportlesshirthtube(l,d,dbore,n,beta,delta,flatlimit)\n  \"supportless\"-prefix: optimized for upside down supportless printability\n  \n  ## Full functonatlity:\n  hirth(l,d,dbore,dpolygon,n,beta,delta,flatlimit,inlimit)\n  rawhirth(beta,delta,n,dpolygon,flatlimit,inlimit)\n  \n  Notes regarding the first design:\n  * The parametric interdependencies behave a little different in this model!\n  * Using volumetric CSG descriptions turns out to be a lot easier than triangle vertex juggling.\n  \n  ###################\n  \n  TODO:\n  \n  refactor:\n  d0 -> dout0\n  dbore0 -> din0\n  same for 00's\n  \n  Maybe:\n  \n  Add an asymmetry parameter \"ddelta\" that rotates the teeth upwards and a \"dbeta\" to compensate for the emerging difference in tooth bottom- and top-wideness. Since the coupling becomes asymmetric a countermpart needs to be made from negative space.\n  make grid with random parameters -- echo(rands(0,10,2));\n  \n  Check if inward facing (or combined inward outward) teeth are possible too.\n  => seems nontrivial\n  \n  \n  Known problems:\n  using rawhirth(...) with intersection works fine\n  using rawhirth(...) with difference not - why ??\n  */\n  \n  \n  // ##########################\n  \n  \n  /* [Character] */\n  \n  // symmetry\n  n0 = 9; // [2:60]\n  // flank angle\n  beta0 = 15;\n  // cone angle (>0)\n  delta0_ = 45;\n  delta0 = abs(delta0_);\n  // size of flat center polygon (edge to edge)\n  dpolygon0 = 14;\n  \n  // (ab)using 0 is BAD!\n  // maximum interlocking/interpenetration depth  (0.. no limit)\n  flatlimit0 = 2;\n  // 0 -> improve upside down printability\n  inlimit00 = 1; // [0:1]\n  inlimit0 = (inlimit00==0) ? false : true;\n  \n  \n  \n  \n  /* [Size] */\n  \n  // height of hirth-joint bottom to center\n  l0 = 16;\n  // outer hirth-coupling diameter\n  d00 = 26;\n  // size of center bore\n  dbore00 = 6;\n  \n  // outer polygon diameter: [0...corner to corner | 1...width across flats]\n  measureout = 1; // [0:1]\n  // inner polygon diameter: [0...corner to corner | 1...width across flats]\n  measurein = 1; // [0:1]\n  \n  // (ab)using 0 is BAD!\n  // number of outer edges (0...circle)\n  nout0 = 0; // [0,3,4,5,6,7,8,9,10,11,12]\n  // number of inner edges (0...circle)\n  nin0 = 0; // [0,3,4,5,6,7,8,9,10,11,12]\n  \n  d0 = (measureout==0 || nout0==0 ) ? d00 : d00 / cos(360/(nout0*2));\n  dbore0 = (measurein ==0 || nin0==0 ) ? dbore00 : dbore00 / cos(360/(nin0 *2));\n  \n  \n  \n  /* [Resolution] */\n  \n  $fa = 4;\n  $fs = 0.2;\n  \n  // Openscad internal stuff needed to be reimplemented:\n  function resol(r) = min(360/$fa, max(6,2*3.1415*r/$fs)); \n  \n  \n  \n  /* [Sidehole] */\n  \n  // hight of sidehole for wormscrew (or whatever)\n  hsidehole = 6;\n  // diameter of sidehole for wormscrew (or whatever)\n  dsidehole = 3;\n  // number of sideholes\n  nsidehole = 3;\n  \n  \n  \n  /* [Keep big] */\n  \n  s0 = 50;\n  \n  \n  \n  /* [Hidden] */\n  \n  colorred = [1,0.3,0.2]*1;\n  colorgreen  = [0.15,0.65,0.1]*1;\n  colorblue = [0.3,0.4,0.7]*1;\n  \n  explx = 16*1;\n  exply = 30*1;\n  exply2 =25*1;\n  shift = 3*1;\n  eps = 0.05*0;\n  \n  // ##################################\n  // -------------------------------- examples\n  \n  customizable();\n  //demo();\n  \n  \n  // customizer default parameter part (tube-example)\n  module customizable()\n  {\n  difference()\n  {\n  color(colorred) translate([0,0,l0+eps]) // <<<<<<< color hack\n  hirth(l0,d0,dbore0,dpolygon0,n0,beta0,delta0,flatlimit0,inlimit0);\n  for(i=[0:nsidehole-1])\n  {\n  rotate(360/nsidehole*i,[0,0,1])\n  translate([0,0,hsidehole]) rotate(90,[0,1,0])\n  cylinder(r=dsidehole/2,h=d0);\n  }\n  }\n  }\n  \n  \n  module demo()\n  {\n  translate([shift,0,10])\n  {\n  translate([-explx,-exply2,0])\n  axledemo();\n  translate([-explx,+exply2,0])\n  axledemo(2,true);\n  \n  translate([+explx,-exply,0])\n  tubedemo();\n  translate([+explx,+exply,0])\n  tubedemo(3,true); // for supportless upside down printing\n  }\n  }\n  \n  \n  \n  module axledemo(flatlimit = 0, inlimit = false) // backwardcapability-demo\n  {\n  color(colorgreen)\n  if(!inlimit)\n  { hirthaxle(10,20,3,6,15,12.5,flatlimit);  } else\n  { supportlesshirthaxle(10,20,6,5,15,25,flatlimit);  }\n  }\n  \n  \n  module tubedemo(flatlimit = 0, inlimit = false)\n  {\n  color(colorblue)\n  if (!inlimit)\n  {  hirthtube(10,32,20,8, 5,45, flatlimit);  } else\n  {  supportlesshirthtube(10,32,20,12, 5,45, flatlimit);  }\n  }\n  \n  \n  \n  // -----------------------------------  convenience functions\n  \n  \n  \n  // axle couplings\n  module hirthaxle(l,d,dbore,n,beta,delta,flatlimit)\n  {\n  dpolygon = 0; inlimit = true;\n  hirth(l,d,dbore,  0  ,n,beta,delta,flatlimit,  inlimit); \n  }\n  // axle couplings && well upside down printable\n  module supportlesshirthaxle(l,d,dbore,n,beta,delta,flatlimit)\n  {\n  dpolygon = 0; inlimit = false;\n  hirth(l,d,dbore,  0  ,n,beta,delta,flatlimit,  inlimit);\n  }\n  \n  \n  \n  // for self centering tube couplings\n  module hirthtube(l,d,dbore,n,beta,delta,flatlimit)\n  {\n  dpolygon = dbore; inlimit = true;\n  hirth(l,d,dbore,  dpolygon , n,beta,delta,flatlimit,  inlimit);\n  }\n  \n  // for self centering tube saped couplings  &&  well upside down printable\n  module supportlesshirthtube(l,d,dbore,n,beta,delta,flatlimit)\n  {\n  dpolygon = dbore; inlimit = false;\n  hirth(l,d,dbore,  dpolygon  ,n,beta,delta,flatlimit,  inlimit);\n  }\n  \n  \n  // ------------------------------------- fundamental functions\n  \n  // basic hirth joint cut to a cylindrical ring \n  module hirth(l,d,dbore,dpolygon,n,beta,delta,flatlimit,inlimit)\n  {\n  \n  cornersout = (nout0==0) ? resol(d/2) : nout0;\n  cornersin  = (nin0==0) ? resol(dbore/2) : nin0;\n  \n  difference()\n  {\n  intersection()\n  {\n  rawhirth(dpolygon,n,beta,delta,flatlimit,inlimit);\n  rotate(360/(cornersout*2),[0,0,1])\n  cylinder(r=d/2,h=2*l,center=true,$fn=cornersout);\n  }\n  \n  // unintuitive ugly hack\n  // to avoid further parameter <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n  //checking (dbore == dpolygon) woud lead to unintuitive behaviour \n  if(inlimit != false || true) \n  {\n  rotate(360/(cornersin*2),[0,0,1])\n  cylinder(r=dbore/2,h=2.2*l,center=true,$fn=cornersin);\n  }\n  else // disabled\n  { \n  rotate(360/n/4,[0,0,1])\n  // polygon avoids blade arcs\n  cylinder(r=dbore/2,h=2*(l0+eps),center=true,$fn=2*n);\n  }\n  \n  }\n  }\n  \n  // \"infinite\" sized raw hirth coupling ( if hs() where a true halfspace )\n  module rawhirth(dpolygon, \n,\n  beta,\n  delta,\n  flatlimit  = 0,\n  inlimit = false,\n  s = s0)\n  {\n  // size of flat center polygon (side to side)\n  shift = dpolygon*cos(360/n/4);\n  \n  // angle per period\n  a = 360/n;\n  \n  // outward upward flanks\n  intersection()\n  {\n  for(i=[0:n-1])\n  {\n  rotate(360*i/n,[0,0,1])\n  intersection()\n  {\n  translate([shift/2,0,0]) \n  rotate(-delta,[0,1,0]) hs(s);\n  rotate(-a/4,[0,0,1])\n  rotate(+(90-beta),[1,0,0]) hs(s);\n  rotate(+a/4,[0,0,1])\n  rotate(-(90-beta),[1,0,0]) hs(s);\n  }\n  }\n  if (flatlimit!=0) { translate([0,0,flatlimit]) hs(s); }\n  }\n  \n  // inward downward flanks and solid lower body\n  union()\n  {\n  intersection()\n  {\n  intersection_for(i = [0 : n])\n  {\n  rotate(360*(i+1/2)/n,[0,0,1])\n  translate([shift/2,0,0]) \n  rotate(+delta,[0,1,0]) hs(s);\n  }\n  hs(s);\n  }\n  if(flatlimit!=0 && inlimit == true)\n  { \n  // cut the teeth bottoms off (flat)\n  translate([0,0,-flatlimit0]) hs(s);\n  }\n \n  }\n  \n  }\n  \n  \n  // halfspace (big-cube-approximation)\n  module hs(s)\n  {\n  translate([0,0,-s/2])\n  cube([s,s,s],center=true);\n  }"},
  "Test_13": {"prompt": "Can you code me an electrical relay in openscad", "completion": "width = 38.6;\n  height = 50.6;\n  relay();\n  module relay(count=2) {\n  \n  difference() {\n  color(\"green\") cube([width,height,2]);\n  translate([3,3,0]) cylinder(r=1.5, h=5);\n  translate([35.6,3,0]) cylinder(r=1.5, h=5);\n  translate([35.6,47.6,0]) cylinder(r=1.5, h=5);\n  translate([3,47.6,0]) cylinder(r=1.5, h=5);\n  }\n  \n  color(\"blue\") translate([3.5,5,0]) cube([15,27,16+2]);\n  color(\"blue\") translate([19.5,5,0]) cube([15,27,16+2]);\n  \n  }\n  \n  module pin(mount_height=5) {\n  cylinder(r=1.4, h=mount_height);\n  }\n  \n  module relay_mount(count=2, mount_height=10, mount_height2=5) {\n  \n  translate([width - 3,height-3,-mount_height]) { cylinder(r=4, h=mount_height); translate([0,0,mount_height]) pin(mount_height2);}\n  translate([3,height-3,-mount_height]) { cylinder(r=4, h=mount_height); translate([0,0,mount_height]) pin(mount_height2);}  \n  translate([3,3,-mount_height]) { cylinder(r=4, h=mount_height); translate([0,0,mount_height]) pin(mount_height2);}  \n  translate([width-3,3,-mount_height]) { cylinder(r=4, h=mount_height); translate([0,0,mount_height]) pin(mount_height2);}  \n  }\n  "},
  "Test_14": {"prompt": "Can you make me a waterproof box in OPenSCad with some drill holes? I don't need a lid, just the box", "completion": "module waterproofBoxCase(\\n  boxSizeX=40,\\n  boxSizeY=60,\\n  boxInnerHeight=25,\\n  boxBottomTopThickness=1.5,\\n  boxScrewCornerRadius=6,\\n  boxScrewDiameter=3.2,\\n  boxWallThickness=3,\\n  barrierThickness=1.2,\\n  barrierHeight=2,\\n  barrierTolerance=0.2,\\n  screwnoseNumber=4,\\n  screwnoseDiameter=4,\\n  screwnoseHeight=5,\\n  screwnoseWallThickness=2.8,\\n  boxClearance = 0.1\\n)\\n{\\n  boxHeight = boxInnerHeight+boxBottomTopThickness;\\n\\tbarrierThickness = boxWallThickness-barrierThickness;\\n\\n\\tdifference()\\n  {\\n\\t\\tunion()\\n  {\\n\\t\\t\\t// solid round box, corners\\n\\t\\t\\ttranslate([boxScrewCornerRadius, boxScrewCornerRadius, 0])\\n  cylinder(r=boxScrewCornerRadius, h=boxHeight, $fn=50); // bottom left\\n\\t\\t\\ttranslate([boxSizeX-boxScrewCornerRadius, boxScrewCornerRadius, 0])\\n  cylinder(r=boxScrewCornerRadius, h=boxHeight, $fn=50); // bottom right\\n\\t\\t\\ttranslate([boxScrewCornerRadius, boxSizeY-boxScrewCornerRadius, 0])\\n  cylinder(r=boxScrewCornerRadius, h=boxHeight, $fn=50); // top left\\n\\t\\t\\ttranslate([boxSizeX-boxScrewCornerRadius, boxSizeY-boxScrewCornerRadius, 0])\\n  cylinder(r=boxScrewCornerRadius, h=boxHeight, $fn=50); // bottom right\\n\\t\\t\\t// solid round box, inner filling\\n\\t\\t\\ttranslate([0, boxScrewCornerRadius, 0])\\n  cube([boxSizeX, boxSizeY-2*boxScrewCornerRadius, boxHeight]);\\n\\t\\t\\ttranslate([boxScrewCornerRadius, 0, 0])\\n  cube([boxSizeX-2*boxScrewCornerRadius, boxSizeY, boxHeight]);\\n\\t\\t\\t// solid round box, top border\\n\\t\\t}\\n\\t\\t// Inner cut-out\\n\\t\\ttranslate([boxWallThickness, boxScrewCornerRadius+boxWallThickness, boxBottomTopThickness])\\n  cube([boxSizeX-2*boxWallThickness, boxSizeY-2*boxScrewCornerRadius-2*boxWallThickness, boxHeight+barrierHeight]);\\n\\t\\ttranslate([boxScrewCornerRadius+boxWallThickness, boxWallThickness, boxBottomTopThickness])\\n  cube([boxSizeX-2*boxScrewCornerRadius-2*boxWallThickness, boxSizeY-2*boxWallThickness, boxHeight+barrierHeight]);\\n\\t\\t// Screw holes\\n\\t\\ttranslate([(boxScrewCornerRadius+boxWallThickness)/2,(boxScrewCornerRadius+boxWallThickness)/2,0])\\n  cylinder(r=boxScrewDiameter/2, h=boxHeight, $fn=20);\\n\\t\\ttranslate([(boxScrewCornerRadius+boxWallThickness)/2,boxSizeY-(boxScrewCornerRadius+boxWallThickness)/2,0])\\n  cylinder(r=boxScrewDiameter/2, h=boxHeight, $fn=20);\\n\\t\\ttranslate([boxSizeX-(boxScrewCornerRadius+boxWallThickness)/2,(boxScrewCornerRadius+boxWallThickness)/2,0])\\n  cylinder(r=boxScrewDiameter/2, h=boxHeight, $fn=20);\\n\\t\\ttranslate([boxSizeX-(boxScrewCornerRadius+boxWallThickness)/2,boxSizeY-(boxScrewCornerRadius+boxWallThickness)/2,0])\\n  cylinder(r=boxScrewDiameter/2, h=boxHeight, $fn=20);\\n\\t\\t// **************************\\n\\t\\t// ** YOUR OWN CUTOUTS HERE!\\n\\t\\t// **************************\\n \\n\\t\\t// **************************\\n\\t\\t// ** / CUTOUTS\\n\\t\\t// **************************\\n\\t}\\n\\t// Lower nose(s)\\n\\tif (screwnoseNumber==2)\\n  translate([boxSizeX/2, 0.001, 0]) mirror([0,1,0])\\n  waterproofBoxScrewNose(screwnoseDiameter, screwnoseHeight);\\n\\tif (screwnoseNumber==4)\\n  {\\n\\t\\ttranslate([boxSizeX*0.25, 0.001, 0]) mirror([0,1,0])\\n  waterproofBoxScrewNose(screwnoseDiameter, screwnoseHeight);\\n\\t\\ttranslate([boxSizeX*0.75, 0.001, 0]) mirror([0,1,0])\\n  waterproofBoxScrewNose(screwnoseDiameter, screwnoseHeight);\\n\\t}\\n\\t// Upper nose(s)\\n\\tif (screwnoseNumber==2)\\n  {\\n  translate([boxSizeX/2, boxSizeY-0.001, 0])\\n  waterproofBoxScrewNose(screwnoseDiameter, screwnoseHeight);\\n  }\\n\\tif (screwnoseNumber==4)\\n  {\\n\\t\\ttranslate([boxSizeX*0.25, boxSizeY-0.001, 0])\\n  waterproofBoxScrewNose(screwnoseDiameter, screwnoseHeight);\\n\\t\\ttranslate([boxSizeX*0.75, boxSizeY-0.001, 0])\\n  waterproofBoxScrewNose(screwnoseDiameter, screwnoseHeight);\\n\\t}\\n}"},
  "Test_15": {"prompt": "Could you make a basic switch in openscad, like a red button I can press ", "completion": "module switch(width = 21.5, height = 26, thickness=25, cover_width=29.70, cover_height=35, cover_thickness=4.7) {\n\n  color(\"black\") cube([width,height,thickness], center=true);\n  color(\"black\") translate([0,0,thickness/2]) cube([cover_width,cover_height,cover_thickness], center=true);\n  color(\"red\") translate([0,0,thickness/2+3]) cube([width,height,4], center=true);\n  \n  }\n  switch();\n  "},
  "Test_16": {"prompt": "Could you make a garden hose in openscad", "completion": "Garden hose\n  sides = 50;\n  \n  connector_garden_hose(5, 0.1);\n  \n  module connector_garden_hose(height, clear)\n  {\n  \n  riA = 14/2;\n  riB = 9/2-0.25;  // rimthickness trouble\n  \n  vert0 = 64;\n  vert1 = 32;\n  \n  t1 = height; // minimum wallthickness\n  r1 = 38/2;\n  \n  // initial standoff\n  t2 = 4; \n  r2 = 20/2;\n  \n  // torodial reduction\n  t3 = 8; \n  r3= 14/2;\n  \n  // trapezoidal\n  t4 = 0.75;\n  t5 = 1.50; r5 = 17/2;\n  t6 = 0.75;\n  s6 = t1+t2+t3+t4+t5+t6;\n  \n  // tip\n  t7 = 2.50;\n  t8 = 3.00;\n  t9 = 3.5;\n  r7 = 16/2;\n  r8 = 11.5/2; // critical\n  r9 = r7;\n  \n  /*\n  todo  \n  smaller tiptorus (2.5mm radius instead of 3.0mm\n  */\n  \n  difference()\n  {\n  \n  union()\n  {\n  \n  cylinder(r=r2,h=t1,$fn=sides);\n  \n  translate([0,0,t1])\n  {\n  cylinder(r=r2,h=t2,$fn=sides);\n  \n  translate([0,0,t2])\n  difference()\n  {\n  cylinder(r=r2,h=t3,$fn=sides);\n  \n  translate([0,0,t3])\n  scale([1,1,t3/(r2-r3)])\n  rotate_extrude(convexity=3, $fn=sides)\n  translate([r2,0,0])\n  circle(r=r2-r3,$fn=sides);\n  }\n  \n  }\n  \n  // trapezoidal part\n  translate([0,0,t1+t2+t3])\n  rotate_extrude(convexity=3, $fn=sides)\n  polygon(points=[[0,0],[r3,0],[r5,t4],[r5,t4+t5],[r7,t4+t5+t6],[0,t4+t5+t6]],paths=[[0,1,2,3,4,5]]);\n  \n  //tip\n  translate([0,0,s6])\n  {\n  cylinder(r = r7, h=t7+t8,$fn=sides) ;\n  translate([0,0,t7+t8+0.5])\n  torus(2.5,r7-2.5,vert1,vert0);\n  // maybe add cylinder here ################### \"t_8_1/2\"\n  }\n  \n  }\n  \n  // too low in z\n  translate([0,0,s6+t7+t8/2])\n  torus(t8/2*sqrt(2), (r7+r8)/2 + (r7-r8)/2*sqrt(2),4,vert0); // test\n  \n  translate([0,0,s6+t7+t8/2])\n  torus(t8/2, r8+t8/2,vert1,vert0); // test\n  \n  translate([0,0,s6+t7+t8/2])\n  torus(t8/2+.9, r8+t8/2+2,vert1,vert0); // test\n  \n  \n  cylinder(r=riB,h= (t1+24)*1.1,$fn=sides);  // to see 24 mm \n  \n  translate([0,0,-0.05])\n  //cylinder(r1=riA,r2=riB,h=10,$fn=vert0);\n  //cylinder(r1=riA,r2=riB,h=10,$fn=vert0);  // h=10 just looks good\n  cylinder(r1=riA+1.0,r2=riB,h=12,$fn=sides);  // h=10 just looks good\n  \n  \n  // DEBUGGING CUT\n  // translate([30,0,0]) cube([60,60,60],center=true);\n  \n  \n  }\n  \n  }\n  \n  module torus(ra,rb,va,vb)\n  {\n  rotate_extrude(convexity=3, $fn=sides)\n  translate([rb,0,0])\n  rotate(45,[0,0,1])\n  circle(r=ra,$fn=sides);"}
}